<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>JSON → Lean Export Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; }
    header { padding: 12px 16px; border-bottom: 1px solid #eee; display: flex; gap: 12px; align-items: center; }
    main { display: grid; grid-template-columns: 360px 1fr; height: calc(100vh - 53px); }
    aside { border-right: 1px solid #eee; overflow: auto; }
    section { height: 100%; overflow: auto; }
    .toolbar { display: flex; gap: 8px; align-items: center; }
    .file-list { list-style: none; margin: 0; padding: 0; }
    .file-list li { padding: 8px 12px; border-bottom: 1px solid #f3f3f3; cursor: pointer; }
    .file-list li:hover { background: #fafafa; }
    .file-list li.active { background: #eef6ff; }
    .panel { padding: 12px 16px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    textarea, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
    pre { background: #fafafa; border: 1px solid #eee; border-radius: 6px; padding: 10px; white-space: pre-wrap; word-break: break-word; }
    .muted { color: #666; }
    .badge { display: inline-block; padding: 2px 6px; border-radius: 999px; background: #eef2ff; color: #3f3f46; font-size: 11px; margin-left: 6px; }
    .split { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .search { display: flex; gap: 8px; }
    .dropzone { border: 1px dashed #9aa0a6; border-radius: 6px; padding: 10px; color: #5f6368; background: #fafafa; cursor: default; }
    .dropzone.drag { background: #eef6ff; border-color: #1a73e8; color: #174ea6; }
  </style>
</head>
<body>
  <header>
    <div class="toolbar">
      <label>
        JSON 文件
        <input type="file" id="jsonInput" accept="application/json" />
      </label>
      <label>
        Lean 目录
        <input type="file" id="leanDirInput" webkitdirectory directory multiple />
      </label>
      <button id="pickLeanDir" title="使用浏览器目录选择器递归读取 .lean">选择 Lean 目录</button>
      <input id="filter" class="search" type="search" placeholder="Filter by id or text…" />
      <span class="badge" id="summary">0 items</span>
      <button id="chooseOutDir" title="选择一个输出文件夹用于保存 Block_XXX.lean">选择输出目录</button>
      <span class="muted" id="outDirName"></span>
      <button id="exportAll" disabled title="将 JSON 中的语句导出为 Block_XXX.lean">导出到所选目录</button>
      <button id="zipDownload" title="将导出内容打包为 ZIP 下载">打包 ZIP 下载</button>
  <span class="badge">｜</span>
  <button id="exportLeanToJson" title="把已加载的 Lean Block 反向导出为 JSON（下载）">Lean→JSON 下载</button>
  <button id="backfillJson" title="将已加载的 Lean Block 回填至已加载的 JSON（字段：main theorem statement，起始1）">回填当前 JSON</button>
  <button id="saveJson" title="下载当前 JSON（包括已回填的内容）">保存当前 JSON</button>
  <button id="backfillBaseJson" title="选择一个基座 JSON，按顺序回填 Lean 内容后下载">回填基座 JSON 并下载</button>
    </div>
  </header>
  <main>
    <aside>
      <ul class="file-list" id="list"></ul>
    </aside>
    <section>
      <div class="panel">
        <div class="dropzone" id="leanDropzone" tabindex="0" aria-label="拖拽 Lean 文件或文件夹到此">拖拽 .lean 文件或文件夹 到此（或使用上方“选择 Lean 目录”/文件夹选择）</div>
        <div class="split">
          <div>
            <h3>JSON Item <span class="muted" id="jsonMeta"></span></h3>
            <pre id="jsonPreview">Load a JSON file to start…</pre>
          </div>
          <div>
            <h3>Lean Block <span class="muted" id="leanMeta"></span></h3>
            <pre id="leanPreview">Select an item to view matching Lean content…</pre>
          </div>
        </div>
      </div>
    </section>
  </main>
  <script>
    // Optional ZIP fallback library
    (function addZipCdn(){
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
      s.defer = true;
      document.head.appendChild(s);
    })();

    const listEl = document.getElementById('list');
    const jsonInput = document.getElementById('jsonInput');
    const leanDirInput = document.getElementById('leanDirInput');
    const jsonPreview = document.getElementById('jsonPreview');
    const leanPreview = document.getElementById('leanPreview');
    const jsonMeta = document.getElementById('jsonMeta');
    const leanMeta = document.getElementById('leanMeta');
    const filterEl = document.getElementById('filter');
    const summary = document.getElementById('summary');
    const chooseOutDirBtn = document.getElementById('chooseOutDir');
    const outDirName = document.getElementById('outDirName');
    const exportAllBtn = document.getElementById('exportAll');
    const zipBtn = document.getElementById('zipDownload');
  const pickLeanDirBtn = document.getElementById('pickLeanDir');
  const dropzone = document.getElementById('leanDropzone');
  const exportLeanToJsonBtn = document.getElementById('exportLeanToJson');
  const backfillBtn = document.getElementById('backfillJson');
  const saveJsonBtn = document.getElementById('saveJson');
  const backfillBaseBtn = document.getElementById('backfillBaseJson');

    let jsonItems = [];
    let leanFiles = new Map(); // name -> text
    let outDirHandle = null; // Directory handle for FS Access API

    jsonInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const data = JSON.parse(text);
        if (!Array.isArray(data)) throw new Error('JSON 顶层应为数组');
        jsonItems = data;
      } catch (err) {
        alert('解析 JSON 失败: ' + err.message);
        return;
      }
      renderList();
    });

    function applyNewLeanFiles(list) {
      leanFiles.clear();
      for (const { name, text } of list) {
        if (name.toLowerCase().endsWith('.lean')) {
          const base = name.split('/').pop();
          leanFiles.set(base, text);
        }
      }
      if (listEl.children.length && listEl.querySelector('.active')) {
        listEl.querySelector('.active').click();
      }
    }

    leanDirInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      const result = [];
      for (const f of files) {
        if (!f.name.endsWith('.lean')) continue;
        result.push({ name: f.name, text: await f.text() });
      }
      applyNewLeanFiles(result);
    });

    pickLeanDirBtn.addEventListener('click', async () => {
      if (!('showDirectoryPicker' in window)) {
        alert('当前浏览器不支持目录选择器。可用“Lean 目录”文件选择或拖拽文件。');
        return;
      }
      try {
        const dir = await window.showDirectoryPicker();
        const gathered = [];
        async function walkDir(handle, prefix = '') {
          for await (const [name, h] of handle.entries()) {
            const path = prefix ? `${prefix}/${name}` : name;
            if (h.kind === 'file') {
              if (!name.endsWith('.lean')) continue;
              const file = await h.getFile();
              const text = await file.text();
              gathered.push({ name: path, text });
            } else if (h.kind === 'directory') {
              await walkDir(h, path);
            }
          }
        }
        await walkDir(dir);
        applyNewLeanFiles(gathered);
      } catch (err) {
        if (err && err.name !== 'AbortError') {
          console.error(err);
          alert('读取目录失败: ' + (err.message || String(err)));
        }
      }
    });

    function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
    ['dragenter','dragover','dragleave','drop'].forEach(evt => {
      dropzone.addEventListener(evt, preventDefaults);
    });
    dropzone.addEventListener('dragenter', () => dropzone.classList.add('drag'));
    dropzone.addEventListener('dragover', () => dropzone.classList.add('drag'));
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('drag'));
    dropzone.addEventListener('drop', async (e) => {
      dropzone.classList.remove('drag');
      const dt = e.dataTransfer;
      const items = dt && dt.items ? Array.from(dt.items) : [];
      // Try webkitGetAsEntry directory traversal if available
      if (items.length && items[0].webkitGetAsEntry) {
        const gathered = [];
        async function walkEntry(entry, prefix = '') {
          if (entry.isFile) {
            await new Promise((res, rej) => {
              entry.file(async (file) => {
                try {
                  if (file.name.endsWith('.lean')) {
                    gathered.push({ name: (prefix ? prefix + '/' : '') + file.name, text: await file.text() });
                  }
                  res(null);
                } catch (err) { rej(err); }
              }, rej);
            });
          } else if (entry.isDirectory) {
            const reader = entry.createReader();
            async function readAll() {
              return new Promise((resolve, reject) => {
                reader.readEntries(async (entries) => {
                  try {
                    if (!entries.length) return resolve(null);
                    for (const ent of entries) {
                      await walkEntry(ent, (prefix ? prefix + '/' : '') + entry.name);
                    }
                    const more = await readAll();
                    resolve(more);
                  } catch (err) { reject(err); }
                }, reject);
              });
            }
            await readAll();
          }
        }
        try {
          for (const it of items) {
            const entry = it.webkitGetAsEntry();
            if (entry) await walkEntry(entry);
          }
          applyNewLeanFiles(gathered);
          return;
        } catch (err) {
          console.error(err);
          // fall through to files list
        }
      }
      // Fallback: plain files list
      const files = Array.from(dt.files || []);
      const result = [];
      for (const f of files) {
        if (!f.name.endsWith('.lean')) continue;
        result.push({ name: f.name, text: await f.text() });
      }
      if (!result.length) {
        alert('未检测到 .lean 文件。若拖拽文件夹，请使用 Chromium 系浏览器或上方按钮。');
        return;
      }
      applyNewLeanFiles(result);
    });

    filterEl.addEventListener('input', () => renderList());

    chooseOutDirBtn.addEventListener('click', async () => {
      if (!('showDirectoryPicker' in window)) {
        alert('当前浏览器不支持选择输出目录（推荐使用 Chrome/Edge）。可使用“打包 ZIP 下载”作为替代。');
        return;
      }
      try {
        outDirHandle = await window.showDirectoryPicker();
        outDirName.textContent = '\uD83D\uDCC1 ' + (outDirHandle.name || '(已选择目录)');
        exportAllBtn.disabled = false;
      } catch (err) {
        if (err && err.name !== 'AbortError') {
          console.error(err);
          alert('选择目录失败: ' + err.message);
        }
      }
    });

    exportAllBtn.addEventListener('click', async () => {
      if (!outDirHandle) { alert('请先选择输出目录'); return; }
      if (!jsonItems.length) { alert('请先加载 JSON 文件'); return; }
      try {
        const { exported, skipped } = await exportJsonToDirectory(outDirHandle, jsonItems);
        alert(`导出完成：写入 ${exported} 个文件，跳过 ${skipped} 个空记录。`);
      } catch (err) {
        console.error(err);
        alert('导出失败: ' + (err?.message || String(err)));
      }
    });

    zipBtn.addEventListener('click', async () => {
      if (!jsonItems.length) { alert('请先加载 JSON 文件'); return; }
      if (!(window.JSZip)) {
        alert('ZIP 依赖未加载（请联网或改用导出到目录）。');
        return;
      }
      try {
        const zip = new JSZip();
        let exported = 0, skipped = 0;
        for (let i = 0; i < jsonItems.length; i++) {
          const idx = i + 1;
          const stmt = extractStmt(jsonItems[i]);
          if (!stmt) { skipped++; continue; }
          const name = makeBlockName(idx);
          zip.file(name, stmt + (stmt.endsWith('\n') ? '' : '\n'));
          exported++;
        }
        const blob = await zip.generateAsync({ type: 'blob' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'lean-blocks.zip';
        a.click();
        URL.revokeObjectURL(a.href);
        alert(`ZIP 已生成：包含 ${exported} 个文件，${skipped} 个空记录跳过。`);
      } catch (err) {
        console.error(err);
        alert('ZIP 生成失败: ' + (err?.message || String(err)));
      }
    });

    function renderList() {
      const q = filterEl.value.trim().toLowerCase();
      listEl.innerHTML = '';
      const items = jsonItems.map((obj, i) => ({
        idx: i + 1,
        id: obj.id ?? i + 1,
        stmt: extractStmt(obj)
      })).filter(it => !q || String(it.id).toLowerCase().includes(q) || it.stmt.toLowerCase().includes(q));

      summary.textContent = items.length + ' items';

      for (const it of items) {
        const li = document.createElement('li');
        const fname = `Block_${String(it.idx).padStart(3,'0')}.lean`;
        const exists = leanFiles.has(fname);
        li.innerHTML = `<strong>#${it.idx}</strong> <span class="muted">id=${it.id}</span> ${exists ? '' : '<span class=badge>no lean</span>'}<br/><span class="muted">${escapeHtml(truncate(it.stmt, 120))}</span>`;
        li.addEventListener('click', () => selectItem(it));
        listEl.appendChild(li);
      }
    }

    function selectItem(it) {
      for (const li of listEl.children) li.classList.remove('active');
      // naive: reselect by index order
      const idx = Array.from(listEl.children).findIndex(node => node.textContent?.includes(`#${it.idx}`));
      if (idx >= 0) listEl.children[idx].classList.add('active');

      jsonMeta.textContent = `#${it.idx} id=${it.id}`;
      jsonPreview.textContent = (it.stmt || '').trim() || '(empty)';

      const fname = `Block_${String(it.idx).padStart(3,'0')}.lean`;
      const lean = leanFiles.get(fname);
      leanMeta.textContent = fname + (lean ? '' : ' (not found)');
      leanPreview.textContent = lean || '(no corresponding Lean file loaded)';
    }

    function extractStmt(obj) {
      return (obj && (obj['main theorem statement'] || obj.main_theorem_statement || obj.main_theorem || obj.statement || '')) || '';
    }
    function makeBlockName(idx) { return `Block_${String(idx).padStart(3,'0')}.lean`; }
    function truncate(s, n) { return s.length > n ? s.slice(0, n - 1) + '…' : s; }
    function escapeHtml(s) { return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    async function exportJsonToDirectory(dirHandle, items) {
      let exported = 0, skipped = 0;
      for (let i = 0; i < items.length; i++) {
        const idx = i + 1;
        const stmt = extractStmt(items[i]);
        if (!stmt || !stmt.trim()) { skipped++; continue; }
        const name = makeBlockName(idx);
        const fileHandle = await dirHandle.getFileHandle(name, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(stmt.endsWith('\n') ? stmt : (stmt + '\n'));
        await writable.close();
        exported++;
      }
      return { exported, skipped };
    }

    function parseBlockIndex(filename) {
      const m = /^Block_(\d+)\.lean$/i.exec(filename || '');
      return m ? parseInt(m[1], 10) : null;
    }

    function buildLeanJsonArray(field = 'main theorem statement') {
      const arr = [];
      for (const [name, text] of leanFiles.entries()) {
        const idx = parseBlockIndex(name);
        if (idx == null) continue;
        const body = (text || '');
        arr.push({ id: idx, [field]: body.endsWith('\n') ? body : (body + '\n') });
      }
      arr.sort((a, b) => a.id - b.id);
      return arr;
    }

    exportLeanToJsonBtn.addEventListener('click', () => {
      if (!leanFiles.size) { alert('请先加载 Lean 文件/目录'); return; }
      const data = buildLeanJsonArray('main theorem statement');
      if (!data.length) { alert('未识别出 Block_XXX.lean'); return; }
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'sfs4_from_lean.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    backfillBtn.addEventListener('click', () => {
      if (!leanFiles.size) { alert('请先加载 Lean 文件/目录'); return; }
      if (!jsonItems.length) { alert('请先加载 JSON 文件'); return; }
      const field = 'main theorem statement';
      const start = 1;
      const leanArr = buildLeanJsonArray(field);
      const map = new Map(leanArr.map(it => [it.id, it[field]]));
      let updated = 0, skipped = 0;
      for (let i = 0; i < jsonItems.length; i++) {
        const idx = start + i;
        if (map.has(idx)) {
          jsonItems[i][field] = map.get(idx);
          updated++;
        } else {
          skipped++;
        }
      }
      renderList();
      alert(`回填完成：更新 ${updated} 条，跳过 ${skipped} 条。`);
    });

    saveJsonBtn.addEventListener('click', () => {
      if (!jsonItems.length) { alert('当前没有 JSON 数据'); return; }
      const blob = new Blob([JSON.stringify(jsonItems, null, 2)], { type: 'application/json;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'sfs4_reshape_with_main.updated.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    backfillBaseBtn.addEventListener('click', async () => {
      if (!leanFiles.size) { alert('请先加载 Lean 文件/目录'); return; }
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = async () => {
        const file = input.files && input.files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const base = JSON.parse(text);
          if (!Array.isArray(base)) { alert('基座 JSON 顶层需为数组'); return; }
          const field = 'main theorem statement';
          const start = 1;
          // build map id->lean by index order
          const leanArr = buildLeanJsonArray(field);
          const map = new Map(leanArr.map(it => [it.id, it[field]]));
          let updated = 0, skipped = 0;
          for (let i = 0; i < base.length; i++) {
            const idx = start + i;
            if (map.has(idx)) {
              base[i][field] = map.get(idx);
              updated++;
            } else {
              skipped++;
            }
          }
          const blob = new Blob([JSON.stringify(base, null, 2)], { type: 'application/json;charset=utf-8' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = (file.name.replace(/\.json$/i, '') || 'base') + '.updated.json';
          a.click();
          URL.revokeObjectURL(a.href);
          alert(`已回填基座：更新 ${updated} 条，跳过 ${skipped} 条。`);
        } catch (err) {
          console.error(err);
          alert('处理基座 JSON 失败: ' + (err.message || String(err)));
        }
      };
      input.click();
    });
  </script>
</body>
</html>
